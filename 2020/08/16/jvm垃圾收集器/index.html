<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>jvm垃圾收集器 | Willis's Note</title><link rel="stylesheet" type="text/css" href="/willis-blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/willis-blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/willis-blog/favicon.ico"><link rel="apple-touch-icon" href="/willis-blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/willis-blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">jvm垃圾收集器</h1><a id="logo" href="/willis-blog/.">Willis's Note</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/willis-blog/."><i class="fa fa-home"> 首页</i></a><a href="/willis-blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/willis-blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/willis-blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">jvm垃圾收集器</h1><div class="post-meta">2020-08-16<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h1><p>很早写过关于内存模型的文章，垃圾收集器一致没有安排时间写，今天整理一些书籍和资源，对java的垃圾收集器做一些总结</p>
<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>根据不同的「垃圾回收算法」，以及不同的「可达性分析」机制，不同jvm厂商也有不同版本的收集器。<br>垃圾收集的本质：同过可达性分析，扫描GC root，将不与GC root结点关联的对象，通过不同的内存回收算法进行回收的过程。</p>
<p>可以作为GC root的对象包含以下几种</p>
<ul>
<li>在虚拟机栈（栈帧中的本地变量表）中引用的对象，如各个线程被调用的方法堆栈中使用到的「参数」、「局部变量」、「临时变量」</li>
<li>在方法区中静态属性引用的对象，如引用类型的静态变量</li>
<li>在方法区中常量引用的对象，譬如字符串常量池里的引用</li>
<li>在本地方法栈中JNI引用的对象</li>
<li>java虚拟机内部的应用。如基本数据类型对应的class对象，一些常驻的异常对象，系统类加载器</li>
<li>所有被同步锁持有的对象</li>
<li>反应jvm内部情况的jmxbean，jvmti中注册的回调、本地代码缓存等</li>
</ul>
<h2 id="垃圾收集器介绍"><a href="#垃圾收集器介绍" class="headerlink" title="垃圾收集器介绍"></a>垃圾收集器介绍</h2><h3 id="Serial收集器"><a href="#Serial收集器" class="headerlink" title="Serial收集器"></a>Serial收集器</h3><p><strong>1. 特点</strong></p>
<ul>
<li>单线程，在进行垃圾收集时，必须暂停其他所有工作线程，直到收集结束【stw】</li>
<li>Serial作为新生代收集器，采用复制算法【相应的，Serial Old作为老年代收集器，采用标记整理算法】</li>
<li>Hot spot虚拟机客户端模式下的默认收集器</li>
</ul>
<h3 id="ParNew收集器"><a href="#ParNew收集器" class="headerlink" title="ParNew收集器"></a>ParNew收集器</h3><p>ParNew收集器实际上是Serial收集器的多线程并行版本。</p>
<p><strong>1. 特点</strong></p>
<ul>
<li>多线程「并行」收集</li>
<li>用用Serial收集器可用的所有控制参数</li>
<li>收集算法、stw，对象分配、回收策略等都与serial收集器一毛一样</li>
<li>新生代</li>
</ul>
<p><strong>2. 局限性</strong></p>
<ul>
<li>在JDK7之前的遗留系统中。除了Serial收集器外，目前只有Parnew收集器能与CMS收集器配合工作</li>
</ul>
<p>CMS收集器是历史上第一个支持垃圾收集线程与用户线上同时工作的收集器。<br>Parnew是激活CMS「-XX:+UseConcMarkSweepGC」后的默认新生代收集器。CMS的出现也巩固了ParNew收集器的地位。<br>JDK9开始后，ParNew + CMS收集器的组合就不再是官方推荐的服务端模式的收集器解决方案，官方希望他完全能被G1取代，甚至取消了ParNew+Serial Old和Serial+CMS这两组收集器组合的支持（实际也很少有人这么用）</p>
<ul>
<li>默认开启的收集线程数与处理器核心数相同，在处理核心数非常多（例如32个）的环境中，可以使用「-XX:ParallelGCThreads」参数来限制垃圾收集的线程数</li>
</ul>
<h3 id="Parallel-Scanvenge收集器"><a href="#Parallel-Scanvenge收集器" class="headerlink" title="Parallel Scanvenge收集器"></a>Parallel Scanvenge收集器</h3><p><strong>1.特点</strong></p>
<ul>
<li>新生代收集器</li>
<li>标记-复制算法</li>
<li>多线程并行收集器</li>
<li>关注点：相比于CMS关注与尽可能缩短垃圾收集时用户线程的停顿时间，Parallel Scanvenge目标是控制吞吐量</li>
</ul>
<blockquote>
<p>吞吐量：处理你用于运行用户代码的时间与处理器总消耗时间的比值。总结来讲：使用cms可能收集次数比较多，但是收集时间浪费很少，用户感知不大；使用ps收集器，可能收集次数很少，但是总的耗时可能比cms多次gc耗时之和要小。</p>
</blockquote>
<p><strong>2.主要控制参数</strong></p>
<ul>
<li>-XX:MaxGCPauseMillis,控制垃圾收集最大停顿时间</li>
<li>-XX:GCTimeRatio直接设置吞吐量大小。参数值是一个0~100的整数，相当于用户线程运行时间与垃圾收集时间的比值。当次参数是19，那么最大垃圾收集时间占总时间的5%（1/(19 + 1)）。默认值99</li>
<li>-XX:+UseAdaptiveSizePolicy。当打开这个配置，就不需要人工配置新生代（-Xxn）、Eden与Survivor比例（-XX:SurvivorRatio）、晋升老年代对象大小（-XX:PretenureSizeThreshold）等细节参数，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大吞吐量。这种调节方式成为垃圾收集的「自适应调节策略」</li>
</ul>
<h3 id="Serial-Old收集器"><a href="#Serial-Old收集器" class="headerlink" title="Serial Old收集器"></a>Serial Old收集器</h3><p><strong>1. 特点</strong></p>
<ul>
<li>是serial收集器的老年代版本，使用标记-整理算法。</li>
<li>HotSpot客户端模式下默认的收集器</li>
</ul>
<p><strong>2. 用途</strong></p>
<ul>
<li>JDK5以前，与Parallel Scanvenge配合使用</li>
<li>CMS收集器发生失败时的后备预案，在并发收集发生 Concurrent Mode Failure是使用</li>
</ul>
<h3 id="Parallel-Old收集器"><a href="#Parallel-Old收集器" class="headerlink" title="Parallel Old收集器"></a>Parallel Old收集器</h3><p><strong>1. 特点</strong></p>
<ul>
<li>Parallel Scanvenge的老年代版本</li>
<li>多线程并发收集，基于标记-整理算法</li>
<li>JDK6开始提供。在之前，除了Serial Old，没有可以与Parallel Scanvenge配合的老年代收集器，没有真正保证“吞吐量优先”的垃圾收集器组合</li>
</ul>
<h3 id="CMS收集器（Concurrent-Mark-Sweep）"><a href="#CMS收集器（Concurrent-Mark-Sweep）" class="headerlink" title="CMS收集器（Concurrent Mark Sweep）"></a>CMS收集器（Concurrent Mark Sweep）</h3><p>CMS收集器是一种以获取最短回收停顿时间为目标的收集器。</p>
<p><strong>1. 使用场景</strong></p>
<ul>
<li>互联网网站或基于浏览器的B/S系统的服务端上，这类应用通常会较为关注服务的响应速度，希望系统停顿时间尽可能短，以给用户带来更好的交互体验</li>
</ul>
<p><strong>2. 特点</strong></p>
<ul>
<li>并发收集、低停顿</li>
<li>老年代，基于标记-清除算法</li>
<li>默认启动垃圾回收线程数是（处理器核心数量+3）/4</li>
</ul>
<p><strong>3. 运作过程</strong></p>
<ul>
<li>初始标记（CMS initial mark）<ul>
<li>stop the world</li>
<li>标记GC Root能「直接关联」的对象</li>
</ul>
</li>
<li>并发标记（CMS concurrent mark）<ul>
<li>从GC Root的直接关联对象开始遍历整个对象图的过程，整个过程时间教程但是不需要停顿用户线程，可以与垃圾收集线程一起并发运行</li>
</ul>
</li>
<li>重新标记（CMS remark）<ul>
<li>stop the world</li>
<li>修正「并发标记」期间，因用户程序继续运作而导致标记产生变动的那一部分对象的标记记录。这个阶段停顿时间通常会比初始标记长一些，但也远少于并发标记的时间<blockquote>
<p>参考《深入理解java虚拟机》，可达性分析一节，三色标记，cms基于增量更新</p>
</blockquote>
</li>
</ul>
</li>
<li>并发清除（CMS concurrent sweep）<ul>
<li>清理删除调标记阶段判断的已经死亡的对象，由于不需要移动存活对象，所以这个阶段可以与用户线程同时并发运行</li>
</ul>
</li>
</ul>
<p><strong>4. 局限性</strong></p>
<ul>
<li>CPU敏感。在并发阶段，虽然不会导致用户线程挺短，但是却会因为占用了一部分线程（处理器的计算能力）而导致应用程序变慢，降低吞吐量。由于默认启动垃圾回收线程数是（处理器核心数量+3）/4，也就是说，如果处理器核心数量在4个或4个以上，并发，并发收集的垃圾收集线程占用不超过25%（核心数趋于正无穷，也才25%），随着核心数增加，这个比例也是整体下降的趋势，最多占用25%的资源。但是如果，处理器核心数不足4个，cms对用户程序影响就可能变得很大（垃圾收集的资源占比高了，导致用户线程可用资源数减少）</li>
<li>浮动垃圾。并发标记和并发清理阶段，用户线程产生的垃圾。也是应为有浮动垃圾，就需要cms收集器不能像其他收集器那样，等老年代完全填满了再进行收集，必须预留一部分空间供并发收集时的程序运作使用。在JDK1.5中，CMS收集器当老年代使用了68%的空间后就会被激活，这个一个保守的设计，如果在十几种老年代增长不是很快，可以适当调高比例，通过参数「-XX:CMSInitialOccupancyFraction」，降低回收频率。JDK6中，默认已经提升到了92%。<br>  <strong>风险：</strong>当CMS运行期间，预留的内存无法满足程序分配新对象的需要，就会出现一次Concurrent Mode Failure，这时虚拟机不得不启动后被预案：冻结用户线程的执行，临时启动Serial Old收集器来重新进行老年的垃圾收集，这样停顿时间就很长了。所以参数「-XX:CMSInitialOccupancyFraction」设置太高容易产生Concurrent Mode Failure错误，性能反而降低，配置时需要根据实际情况进行权衡</li>
<li>基于标记-清除算法，意味着会产生大量的空间碎片。碎片过多，会导致大对象分配的困难，一旦没有空间分配给大对象，及时空间剩余很多，也会产生一次Full GC。<ul>
<li>为了解决这个问题，CMS提供了一个参数「-XX:+UseCMSCompactAtFullCollection, JDK9废弃了」，用于在CMS收集器不得不进行Full GC时开启内存碎片的合并整理过程，由于内存整理必须移动存活对象，（shenandoah和ZGC出现前）是无法并发的。</li>
<li>这样空间碎片问题解决了，但是停顿时间边长了，因此虚拟机提供了另一个参数「-XX:CMSFullGcsBeforeCompaction,JDK9开始废弃」，这个参数的作用要求CMS收集器在执行过若干次（参数值）不整理空间的Full GC后下一次进入Full GC前会先进性碎片整理。默认值是0，即每次进入Full GC时都会进行碎片整理</li>
</ul>
</li>
</ul>
<h3 id="Garbage-First收集器"><a href="#Garbage-First收集器" class="headerlink" title="Garbage First收集器"></a>Garbage First收集器</h3><p><strong>1. 特点</strong></p>
<ul>
<li>主要面向服务端</li>
<li>Mixed GC模式。不再局限于新生代、老年代，没有这些概念了。面向内存块，那块内存垃圾数量最多，回收收益最大。</li>
<li>遵循分带收集理论设计，但不再坚持固定大小以及固定数量的分带区域划分，而是把连续的java堆划分为多少个大小相等的独立区域（Region），每一个region都可以根据需要，扮演eden空间。Survivor空间或者老年代空间</li>
<li>Region中包含一类特殊的Humongous区域，专门用来存储大对象。G1认为只要大小超过了一个Region容量一半的对象可判定为大对象。<ul>
<li>Region大小可以通过参数「-XX:G1HeapRegionSize」设定，取值范围1MB~32MB，且必须为2的n次幂。</li>
<li>对于那些超过了这个Region容量的超级大对象，将会被存放在N个连续的Humongous Region之中，G1的大多数行为都把Humongous Region作为老年代的一部分来进行看待</li>
</ul>
</li>
<li>新生代和老年代都是一系列Region（不需要连续）的动态集合</li>
<li>可预测停顿时间的回收模型。每次将Region作为单词回收的最小单元，每次收集到的内存空间都是region大小的整数倍，这样可以有计划的避免在整个java堆中进行全区域的垃圾收集。<blockquote>
<p>G1收集器去跟踪各个region里面的垃圾堆积的价值大小，价值即回收所获得的空间大小以及回收所需时间的经验值，然后在后台维护一个优先级列表，每次根据用户设定的允许收集停顿时间（通过「-XX:MaxGCPauseMillis」，默认200ms），优先处理回收价值收益最大的那些Region</p>
</blockquote>
</li>
</ul>
<p><strong>2. 面临的问题</strong></p>
<ul>
<li>跨Region引用问题。使用记忆集（Remembered Set），避免全堆作为GC Root扫描。在G1中，记忆集的应用要复杂很多，每个Region都维护自己的记忆集，这些记忆集都会记录下别的Region指向自己的指针，并标记这些指针分别在那些卡页的范围之内。G1的记忆集是一种hash表，Key是别的region的起始地址，value是一个集合，里面存储的元素是卡表的索引号。这种「双向」的卡表结构（卡表维护了我指向了谁，这种结构还维护了谁指向了我），比原来的卡表实现起来更复杂，同时region的数量比传统的收集器的分带数量（一个老年代，一个eden，两个survivor…）要多得多。因此，G1至少要耗费大约相当于对容量的10%~20%的额外内存来维持收集器的工作。</li>
<li>并发标记阶段如何保证收集线程与用户线程互不干扰的运行？如用户线程运行期间改变了引用关系。G1通过原始快照算法（SATB）来实现。G1收集器为每个Region设计了两个名为TAMS（Top At Mark Start）的指针，把Region中的一部分空间划分出来用于并发回收过程中新对象分配，并发回收时新分配的对象地址都必须要在两个指针位置以上。G1收集器默认在整个地址以上的对象都是存活的，「不纳入回收范围」。与CMS的 CMF失败导致Full GC类似，如果内存回收的速度赶不上内存分配的速度，G1收集器也要被冻结用户线程执行，导致Full GC而产生长时间STW。</li>
<li>「可靠的停顿预测模型如何建立」。通过「-XX:MaxGCPauseMillis(期望停顿时间)」参数指定的停顿时间只是垃圾收集之前，「用户期望」垃圾回收所耗费的时间。G1收集器的停顿预测模型是一衰减均值为理论基础实现的，在垃圾收集过程中，G1收集器会记录每个Region的回收耗时，每个region记忆集里的脏卡数量等各个可测量的步骤花费的成本，并分析得出平均值，标注偏差、置信度等统计信息。「衰减平均值」是指他会比普通的平均值，更容易受到新数据的影响。平均值代表整体的平均状态，衰减平均值更准确的代表「最近的」平均状态。也就是说，Region的统计状态越新越能决定其回收的价值。通过这些信息预测从现在开始进行回收的话，由哪些Region组成的回收集才可以在不超过「期望停顿时间」的约束下获得最高收益。</li>
</ul>
<p><strong>3. 运作过程</strong></p>
<ul>
<li><p>「初始标记」</p>
<ul>
<li>标记GCRoot能直接关联到的对象</li>
<li>修改TAMS指针，为「并发标记」阶段用户在Region中分配对象提供支撑</li>
<li>stop the world</li>
</ul>
</li>
<li><p>「并发标记」</p>
<ul>
<li>从GC Root开始对堆中对象进行可达性分析，递归扫描整个堆里的对象图，找出要回收的对象，耗时较长。</li>
<li>重新处理SATB记录下的在并发时有引用变动的对象</li>
<li>可与用户线程并发执行</li>
</ul>
</li>
<li><p>「最终标记」</p>
<ul>
<li>处理并发阶段结束后仍遗留下来的最后那少量的SATB记录</li>
<li>短暂stop the world</li>
</ul>
</li>
<li><p>「筛选回收」</p>
<ul>
<li>更新region统计数据</li>
<li>对各个Region的回收价值和成本进行排序</li>
<li>根据用户期望停顿时间制定回收计划。自由选择任意多个Region构成回收集，然后把决定回收的那一部分Region的存活对象复制到空的Region中，在清理掉整个旧Region的全部空间</li>
<li>涉及到存活对象移动，需要stop the world</li>
</ul>
</li>
<li><p><strong>总结：</strong>G1收集器，除了并发标记阶段，其余阶段都是需要stop the world。也就是说，G1收集器并非纯粹追求低延迟。官方订的目标：在延迟可控的情况下获得尽可能高的吞吐量。</p>
</li>
</ul>
<p><strong>4. 后语</strong>：</p>
<ul>
<li>用户自己指定期望停顿时间是G1收集器很强大的一个功能。通过设置不同的期望值，可使得G1在不同的应用场景中取得关注吞吐量和关注延迟之间的最佳平衡<ul>
<li>默认期望停顿时间是200毫秒，通常把期望停顿时间设置为100到300毫秒回事比较合理的</li>
<li>如果把期望停顿时间设置过小，如20毫秒，很可能由于停顿时间太短，导致每次选出来的回收集只占堆内存很小一部分，收集器收集速度逐渐跟不上分配器分配的速度，导致垃圾慢慢堆积，时间一长，最终沾满对引发Full Gc降低性能。</li>
</ul>
</li>
<li>G1开始，最先进的垃圾收集器的设计导向都变为追求能够应付应用的内存分配速率，而不追求依次把整个堆全部清理干净。这样，应用在分配，收集器在收集，只要收集跟得上分配的速度，一切运作都很完美</li>
<li>G1 与 CMS 比较<ul>
<li>CMS采用「标记-清除」算法。G1从整体上讲是基于「标记-整理」算法，局部（两个region之间）上讲是基于「标记-复制」算法，这两种算法都不会产生内存空间碎片。</li>
<li>垃圾回收的内存占用，G1要比CMS高。如，G1的卡表实现复杂，而且每个Region都有卡表（卡表数量就是region的数量），导致G1的记忆集可能会占整个堆容量的20%乃至更多的空间；CMS卡表简单，只有一份，而且只需要处理老年代到新生代的引用，反过来不需要，由于新生代具有朝生夕死的不稳定性，引用变化频繁，能剩下整个区域的维护开销也很划算</li>
<li>CMS用「写后屏障」来维护更新卡表；G1除了使用「写后屏障」来进行同样卡表维护操作位，为了实现原始快照搜索（SATB）算法，还需要使用「写前屏障」来跟踪并发是的指针变化情况</li>
</ul>
</li>
</ul>
<p><strong>关于2者比较，当前很难说哪个更好。小内存应用上CMS的表现大概率由于G1。而大内存应用上G1则大多能发挥其优势。这个优势的java对容量平衡点通常在6G~8G之间。随着HotSpot研发团队的不断优化，G1收集器也将会全面取代CMS</strong></p>
<blockquote>
<p>SATB：Snapshot At The Beginning</p>
</blockquote>
<h3 id="Shenandoah收集器"><a href="#Shenandoah收集器" class="headerlink" title="Shenandoah收集器"></a>Shenandoah收集器</h3><p>** 连接：<a target="_blank" rel="noopener" href="https://shipilev.net/talks/devoxx-Nov2017-shenandoah.pdf">https://shipilev.net/talks/devoxx-Nov2017-shenandoah.pdf</a> **<br>P13</p>
<p>待补充</p>
<h3 id="ZGC"><a href="#ZGC" class="headerlink" title="ZGC"></a>ZGC</h3><p>JDK11引入，以实验性质<br>待补充</p>
<hr>
<p>参考文献<br>《深入理解java虚拟机》</p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/willis-blog/2020/08/22/Mysql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/">Mysql常用查询</a><a class="next" href="/willis-blog/2020/08/07/Redis%E7%9A%84%E6%8C%81%E4%B9%85%E5%8C%96/">Redis 持久化</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://willis-song.gitee.io/willis-blog"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/willis-blog/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/willis-blog/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/willis-blog/tags/elastic/" style="font-size: 15px;">elastic</a> <a href="/willis-blog/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/willis-blog/tags/Swarm/" style="font-size: 15px;">Swarm</a> <a href="/willis-blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 15px;">微服务</a> <a href="/willis-blog/tags/%E6%B8%B8%E7%8E%A9/" style="font-size: 15px;">游玩</a> <a href="/willis-blog/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/willis-blog/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" style="font-size: 15px;">反向代理</a> <a href="/willis-blog/tags/IO/" style="font-size: 15px;">IO</a> <a href="/willis-blog/tags/%E5%90%8C%E6%AD%A5IO/" style="font-size: 15px;">同步IO</a> <a href="/willis-blog/tags/%E5%BC%82%E6%AD%A5IO/" style="font-size: 15px;">异步IO</a> <a href="/willis-blog/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" style="font-size: 15px;">多路复用</a> <a href="/willis-blog/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/willis-blog/tags/java/" style="font-size: 15px;">java</a> <a href="/willis-blog/tags/InnoDb/" style="font-size: 15px;">InnoDb</a> <a href="/willis-blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/willis-blog/tags/%E7%94%A8%E6%88%B7%E6%80%81/" style="font-size: 15px;">用户态</a> <a href="/willis-blog/tags/%E6%A0%B8%E6%80%81/" style="font-size: 15px;">核态</a> <a href="/willis-blog/tags/%E7%AE%A1%E6%80%81/" style="font-size: 15px;">管态</a> <a href="/willis-blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/willis-blog/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/willis-blog/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 15px;">进程</a> <a href="/willis-blog/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">线程</a> <a href="/willis-blog/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/" style="font-size: 15px;">共享内存</a> <a href="/willis-blog/tags/%E5%86%85%E5%AD%98/" style="font-size: 15px;">内存</a> <a href="/willis-blog/tags/netty/" style="font-size: 15px;">netty</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/10/14/Netty%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Netty实现原理与源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/10/10/IO%E7%9A%84%E8%BF%9B%E5%8C%96/">IO的进化过程</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/09/25/Nginx-%E9%85%8D%E7%BD%AE/">Nginx-配置</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-kafka-1/">消息队列-kafka-1</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统-内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/06/03/Maven%E7%9A%84docker%E6%8F%92%E4%BB%B6/">Maven的Docker插件</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B&%E7%BA%BF%E7%A8%8B/">操作系统-进程/线程</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E6%9C%BA%E7%89%B9%E6%9D%83%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">操作系统-处理机特权级相关知识</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/18/Docker%E5%B7%A5%E5%85%B7-Docker%20Machine/">Docker Machine</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/13/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">docker网络模型</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/willis-blog/." rel="nofollow">Willis's Note.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/willis-blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/willis-blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/willis-blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/willis-blog/js/smartresize.js?v=1.0.0"></script></div></body></html>