<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>Redis数据结构 | Willis's Note</title><link rel="stylesheet" type="text/css" href="/willis-blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/willis-blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/willis-blog/favicon.ico"><link rel="apple-touch-icon" href="/willis-blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/willis-blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Redis数据结构</h1><a id="logo" href="/willis-blog/.">Willis's Note</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/willis-blog/."><i class="fa fa-home"> 首页</i></a><a href="/willis-blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/willis-blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/willis-blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Redis数据结构</h1><div class="post-meta">2021-10-23<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>在Redis中， 数据类型很多，不同数据类型都有很多相同的信息要记录，所以Redis设计了一个核心的类型：「<strong>RedisObject</strong>」</font><br><img src="/willis-blog/images/2021-10-23/redis-object.svg" alt="&lt;Strong&gt;RedisObject与相关数据结构&lt;/Strong&gt;"></p>
<figure class="highlight c"><figcaption><span>[redisObject定义]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">redisObject</span> &#123;</span></span><br><span class="line">    <span class="keyword">unsigned</span> type:<span class="number">4</span>;       <span class="comment">// RedisObject的类型</span></span><br><span class="line">    <span class="keyword">unsigned</span> encoding:<span class="number">4</span>;   <span class="comment">// 同一种类型的RedisObject数据有不同的编码形式</span></span><br><span class="line">    <span class="keyword">unsigned</span> lru:LRU_BITS; <span class="comment">/* 记录RedisObject访问时间信息，在Redis设置了内</span></span><br><span class="line"><span class="comment">                            * 存上限限制之后会根据该属性来回收redisObject</span></span><br><span class="line"><span class="comment">                            * 从而达到释放内存的效果</span></span><br><span class="line"><span class="comment">                            * LRU time (relative to global lru_clock) or</span></span><br><span class="line"><span class="comment">                            * LFU data (least significant 8 bits frequency</span></span><br><span class="line"><span class="comment">                            * and most significant 16 bits decreas time). */</span></span><br><span class="line">    <span class="keyword">int</span> refcount;          <span class="comment">// 引用计数，在Redis中同一个RedisObject可能被多个地方共用</span></span><br><span class="line">    <span class="keyword">void</span> *ptr;             <span class="comment">// 指向底层实现数据结构的指针</span></span><br><span class="line">&#125; robj;</span><br></pre></td></tr></table></figure>

<h2 id="Redis数据结构"><a href="#Redis数据结构" class="headerlink" title="Redis数据结构"></a>Redis数据结构</h2><h3 id="String"><a href="#String" class="headerlink" title="String"></a>String</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>Redis没有直接使用C语言传统的字符串表示（以空字符结尾的字符数组，以下简称C字符串），而是自己构建了一种名为简单动态字符串（simple dynamic string，SDS）的抽象类型，并将SDS用作Redis的默认字符串表示。</font></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>当Redis需要的不仅仅是一个字符串字面量，而是一个可以被修改的字符串值时，Redis就会使用SDS来表示字符串值，比如在Redis的数据库里面，包含字符串值的<strong>键值对</strong>在底层都是由SDS实现的。例如</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>那么Redis将在数据库中创建一个新的键值对，其中：</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>键值对的「键」是一个字符串对象，对象的底层实现是一个保存着字符串”msg”的SDS。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>键值对的「值」也是一个字符串对象，对象的底层实现是一个保存着字符串”hello world”的SDS。</font></p>
<h4 id="SDS"><a href="#SDS" class="headerlink" title="SDS"></a>SDS</h4><figure class="highlight c"><figcaption><span>[sds.h/sdshdr]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sdshdr</span> &#123;</span></span><br><span class="line">    <span class="comment">// 记录buf数组中已使用字节的数量</span></span><br><span class="line">    <span class="comment">// 等于SDS所保存字符串的长度</span></span><br><span class="line">    <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 记录buf数组中未使用字节的数量</span></span><br><span class="line">    <span class="keyword">int</span> <span class="built_in">free</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 字节数组，用于保存字符串。可以保存一些列二进制数据</span></span><br><span class="line">    <span class="keyword">char</span> buf[];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/willis-blog/images/2021-10-23/sds.svg" alt="&lt;Strong&gt;sds结构&lt;/Strong&gt;"><br><img src="/willis-blog/images/2021-10-23/sds-2.svg" alt="&lt;Strong&gt;带有未使用空间的sds&lt;/Strong&gt;"><br><strong>关于空间分配</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>与C字符串对比， 在c中，字符串并不会记录自身的长度，所以对于一个包含了N个字符的C字符串来说，这个C字符串的底层实现总是一个N+1个字符长的数组（额外的一个字符空间用于保存空字符）因为C字符串的长度和底层数组的长度之间存在着这种关联性，所以每次增长或者缩短一个C字符串，程序都总要对保存这个C字符串的数组进行一次内存重分配操作。</font></p>
<blockquote>
<p>如果程序执行的是增长字符串的操作，比如拼接操作（append），那么在执行这个操作之前，程序需要先通过内存重分配来扩展底层数组的空间大小——如果忘了这一步就会产生缓冲区溢出。<br>如果程序执行的是缩短字符串的操作，比如截断操作（trim），那么在执行这个操作之后，程序需要通过内存重分配来释放字符串不再使用的那部分空间——如果忘了这一步就会产生内存泄漏。</p>
</blockquote>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>为了避免C字符串的这种缺陷，SDS通过未使用空间解除了字符串长度和底层数组长度之间的关联：在SDS中，buf数组的长度不一定就是字符数量加一，数组里面可以包含未使用的字节，而这些字节的数量就由SDS的free属性记录。<strong>分配策略如下：</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>1) 空间预分配， 如果对SDS进行修改之后，SDS的长度（也即是len属性的值）将小于1MB，那么程序分配和len属性同样大小的未使用空间，这时SDS len属性的值将和free属性的值相同</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>2) 如果对SDS进行修改之后，SDS的长度将大于等于1MB，那么程序会分配1MB的未使用空间</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>如果修改后的字符串变长了，且free中的长度足够分配新的字符串， 那么就不用执行重新内存分配逻辑。这种分配策略，SDS将连续增长N次字符串所需的内存重分配次数从必定N次降低为最多N次。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>空间释放策略</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>空间释放采用<strong>惰性释放策略</strong>。 当字符串修改之后变短了，也并不会马上释放空间，free<br>中记录着剩余空间。 这样做的好处是，当字符串再被修改变大时，可能省去了再去申请空间的麻烦。</font></p>
<h4 id="String的编码"><a href="#String的编码" class="headerlink" title="String的编码"></a>String的编码</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>String类型的数据结构存储方式有三种int、raw、embstr</font></p>
<ul>
<li><p>int<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>Redis中规定假如存储的是「整数型值」，比如set num 123这样的类型，就会使用 int的存储方式进行存储，在redisObject的「ptr属性」中就会保存该值。int没有sdshdr对象,Long刚好跟指针的字节数一样</font></p>
</li>
<li><p>embstr<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>当保存的是字符串数据，并且字符串小于等于 44 字节时，RedisObject 中的元数据、指针和 SDS 是一块「连续的内存区域」，这样就可以避免内存碎片。这种布局方式也被称为 embstr 编码方式</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>为什么是44呢？</strong>结合下面的图[Redis-String]</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5 color=#7C0219>redisObj结构中中，元数据： type字段占4bit， encoding字段占4bit，lru占24bit（3字节），refcount占4byte，加起来占8byte；</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4. color=#7C0219>sdshdr中， len占1byte，free占1byte，buf长度动态，结束字符’\0’占一个字节，还有一个flag字段占1byte。flag字段是redis3.2之后新加的，用来标志sdshdr具体类型。因为在redis3.2之后，将原来的sdshdr改成了sdshdr8，sdshdr16，sdshdr32，sdshdr64，里面的unsigned int 变成了uint8_t（8位整数）,uint16_t（16位整数）等等。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4. color=#7C0219>从2.4版本开始，redis开始使用jemalloc内存分配器。可以简单理解，jemalloc不是一个一个字节来申请和分配的，会分配8，16，32，64等字节的内存（如需要12个字节，就会分配16个字节）</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4. color=#7C0219>综上3点， ”短字符串“这种场景下，除了buf，需要空间为：8（元数据） + 8（ptr） + 4（dsdhdr8）=20bytes。jemalloc最小分配内存位8bytes， 所以最小分配空间位20+8=28bytes。这里28个字节，分配32字节就够了，为啥要64字节呢。参考这篇文章(<a target="_blank" rel="noopener" href="https://www.codeleading.com/article/87633231412/)[https://www.codeleading.com/article/87633231412/]">https://www.codeleading.com/article/87633231412/)[https://www.codeleading.com/article/87633231412/]</a>. 其实就是，3.2以后的版本中，sds被细分成了sdshd5，sdshdr8，sdshdr16，sdshdr32，sdshdr64。每种类型都有自己的最大取值范围：2^5=32byte，2^8=256byte，2^16=65536byte=64KB，2^32byte=4GB. 在源码中有一段，如下：</font></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在sds.c文件中</span></span><br><span class="line"><span class="function">sds <span class="title">sdsnewlen</span><span class="params">(<span class="keyword">const</span> <span class="keyword">void</span> *init, <span class="keyword">size_t</span> initlen)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *sh;</span><br><span class="line">    sds s;</span><br><span class="line">    <span class="keyword">char</span> type = sdsReqType(initlen);</span><br><span class="line">    <span class="comment">/* Empty strings are usually created in order to append. Use type 8</span></span><br><span class="line"><span class="comment">     * since type 5 is not good at this. */</span></span><br><span class="line">    <span class="comment">// 这里说明，type5也要用SDS_TYPE_8来处理</span></span><br><span class="line">    <span class="keyword">if</span> (type == SDS_TYPE_5 &amp;&amp; initlen == <span class="number">0</span>) type = SDS_TYPE_8;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 省略部分......</span></span><br><span class="line">    <span class="keyword">switch</span>(type) &#123;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_5: &#123;</span><br><span class="line">            *fp = type | (initlen &lt;&lt; SDS_TYPE_BITS);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> SDS_TYPE_8: &#123;</span><br><span class="line">            SDS_HDR_VAR(<span class="number">8</span>,s);</span><br><span class="line">            sh-&gt;len = initlen;</span><br><span class="line">            sh-&gt;alloc = initlen;</span><br><span class="line">            *fp = type;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      。。。。。。。。。。。。。。。。。。。。。。。</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (initlen &amp;&amp; init)</span><br><span class="line">        <span class="built_in">memcpy</span>(s, init, initlen);</span><br><span class="line">    s[initlen] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">    <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4. color=#7C0219>所以，32字节也要用sdshdr8处理，他处理的空间范围是大于32的，在sdshdr8这里最小分配要64字节。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4. color=#7C0219>除了buf占20byte。 当字节数小于44是，都是占用64字节（64-20）</font></p>
</li>
<li><p>raw<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>当字符串大于44字节时，SDS的数据量就开始变多了，Redis 就不再把SDS 和 RedisObject 布局在一起了，而是会给 SDS 分配独立的空间，并用指针指向 SDS 结构。这种布局方式被称为 raw 编码模式</font><br><img src="/willis-blog/images/2021-10-23/redis-string-1.svg" alt="&lt;Strong&gt;Redis-String&lt;/Strong&gt;"></p>
</li>
</ul>
<h3 id="Hash"><a href="#Hash" class="headerlink" title="Hash"></a>Hash</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>Hash对象的实现方式有两种分别是ziplist、hashtable，其中hashtable的存储方式key是String类型的，value也是以key value的形式进行存储。</font></p>
<h4 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>在介绍hash结构之前，先介绍一下「字典」</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>字典，又称为符号表（symbol table）、关联数组（associative array）或映射（map），是一种用于保存键值对（key-value pair）的抽象数据结构。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>字典在Redis中的应用相当广泛，比如Redis的数据库就是使用字典来作为底层实现的，对数据库的增、删、查、改操作也是构建在对字典的操作之上的。例如</font></p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">redis&gt;</span><span class="bash"> SET msg <span class="string">&quot;hello world&quot;</span></span></span><br><span class="line">OK</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>在数据库中创建一个键为”msg”，值为”hello world”的键值对时，这个键值对就是保存在代表数据库的字典里面的</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>除了用来表示数据库之外，字典还是哈希键的底层实现之一，当一个哈希键包含的键值对比较多，又或者键值对中的元素都是比较长的字符串时，Redis就会使用字典作为哈希键的底层实现</font></p>
<h4 id="字典的实现"><a href="#字典的实现" class="headerlink" title="字典的实现"></a>字典的实现</h4><figure class="highlight c"><figcaption><span>[字典hash]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictht</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表数组</span></span><br><span class="line">    dictEntry **table;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表大小</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> size;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//哈希表大小掩码，用于计算索引值</span></span><br><span class="line">    <span class="comment">//总是等于size-1</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> sizemask;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 该哈希表已有节点的数量</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">long</span> used;</span><br><span class="line">    </span><br><span class="line">&#125; dictht;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>table属性是一个数组，数组中的每个元素都是一个指向dict.h/dictEntry结构的指针，每个dictEntry结构保存着一个键值对。size属性记录了哈希表的大小，也即是table数组的大小，而used属性则记录了哈希表目前已有节点（键值对）的数量。sizemask属性的值总是等于size-1，这个属性和哈希值一起决定一个键应该被放到table数组的哪个索引上面。</font><br><img src="/willis-blog/images/2021-10-23/hash-empty.png" alt="&lt;Strong&gt;hash-empty&lt;/Strong&gt;"></p>
<figure class="highlight c"><figcaption><span>[hash表节点]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 键</span></span><br><span class="line">    <span class="keyword">void</span> *key;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 值</span></span><br><span class="line">    <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">        <span class="keyword">void</span> *val;</span><br><span class="line">        uint64_tu64;</span><br><span class="line">        int64_ts64;</span><br><span class="line">    &#125; v;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 指向下个哈希表节点，形成链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dictEntry</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125; dictEntry;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>key属性保存着键值对中的键，而v属性则保存着键值对中的值，其中键值对的值可以是一个指针，或者是一个uint64_t整数，又或者是一个int64_t整数。<br>next属性是指向另一个哈希表节点的指针，这个指针可以将多个哈希值相同的键值对连接在一次，以此来解决键冲突（collision）的问题</font></p>
<figure class="highlight c"><figcaption><span>[字典实现]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">dict</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 类型特定函数</span></span><br><span class="line">    dictType *type;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 私有数据</span></span><br><span class="line">    <span class="keyword">void</span> *privdata;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 哈希表</span></span><br><span class="line">    dictht ht[<span class="number">2</span>];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// rehash索引</span></span><br><span class="line">    <span class="comment">//当rehash不在进行时，值为-1</span></span><br><span class="line">    in rehashidx; <span class="comment">/* rehashing not in progress if rehashidx == -1 */</span></span><br><span class="line"></span><br><span class="line">&#125; dict;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>type属性是一个指向dictType结构的指针，每个dictType结构保存了一簇用于操作特定类型键值对的函数，Redis会为用途不同的字典设置不同的类型特定函数</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>而privdata属性则保存了需要传给那些类型特定函数的可选参数</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>ht属性是一个包含两个项的数组，数组中的每个项都是一个dictht哈希表，一般情况下，字典只使用ht[0]哈希表，ht[1]哈希表只会在对ht[0]哈希表进行rehash时使用</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>除了ht[1]之外，另一个和rehash有关的属性就是rehashidx，它记录了rehash目前的进度，如果目前没有在进行rehash，那么它的值为-1</font><br><img src="/willis-blog/images/2021-10-23/dict-1.svg" alt="&lt;Strong&gt;dict&lt;/Strong&gt;"></p>
<h4 id="hash扩容-渐进式rehash"><a href="#hash扩容-渐进式rehash" class="headerlink" title="hash扩容:渐进式rehash"></a>hash扩容:渐进式rehash</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>Redis将所有的rehash的操作分成多步进行，直到都rehash完成，具体的实现与对象中的rehashindex属性相关，「若是rehashindex 表示为-1表示没有rehash操作」.</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>当rehash操作开始时会将rehashindex改成0，在渐进式rehash的过程中，「更新、删除、查询会在ht[0]和ht[1]中都进行」，比如更新一个值先更新ht[0]，然后再更新ht[1]。而新增操作直接就新增到ht[1]表中，ht[0]不会新增任何的数据，这样保证「ht[0]只减不增，直到最后的某一个时刻变成空表」，然后将ht[1]置为ht[0]这样rehash操作完成。</font></p>
<h4 id="ziplist实现"><a href="#ziplist实现" class="headerlink" title="ziplist实现"></a>ziplist实现</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>当 <strong>哈希类型</strong> 元素个数小于hash-max-ziplist-entries配置（默认512个）、同时所有值都小于「hash-max-ziplist-value」配置（默认64字节）时，Redis会使用ziplist作为哈希的内部实现，ziplist使用更加紧凑的结构实现多个元素的连续存储，所以在节省内存方面比hashtable更加优秀。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>压缩表是一组连续内存块组成的顺序的数据结构，压缩列表能够节省空间，压缩列表中使用多个节点来存储数据。压缩列表是列表键和哈希键底层实现的原理之一，「压缩列表并不是以某种压缩算法进行压缩存储数据，而是它表示一组连续的内存空间的使用，节省空间」，压缩列表的内存结构图如下</font><br><img src="/willis-blog/images/2021-10-23/ziplist.svg" alt="&lt;Strong&gt;ziplist&lt;/Strong&gt;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>zlbytes</strong>：4个字节的大小，记录压缩列表占用内存的字节数。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>zltail：4个字节大小，记录表尾节点距离起始地址的偏移量，用于快速定位到尾节点的地址。</strong></font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>zllen</strong>：2个字节的大小，记录压缩列表中的节点数。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>entry</strong>：表示列表中的每一个节点。zlend：表示压缩列表的特殊结束符号’0xFF’。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>每一个entry节点又有三部分组成:</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>prev_len</strong>: 表示前一个节点entry的长度，可用于计算前一个节点的其实地址，因为他们的地址是连续的。</font><font size=4.5 color=#7C0219>如果内容小于254，prevlen用一个字节存储，如果大于254，就用五个字节存储。 这里需要考虑到级联更新，如果连续几个节点长度都是250~253，那么一旦最前面一个变大「超过了254」，导致后续几点的prelen字段也膨胀了4倍，可能也会导致后面节点超过254</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>encoding</strong>: 这里保存的是content的内容类型和长度</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>content</strong>: content保存的是每一个节点的内容</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5 color=#7C0219>压缩表的不能提高查找速速，需要一个一个遍历。如果数据量太多，重新分配内存和拷贝数据会有很大的消耗。所以压缩表不适合存储大型字符串，并且数据元素不能太多。hash-max-ziplist-entries不宜设置过大</font></p>
<h3 id="List类型"><a href="#List类型" class="headerlink" title="List类型"></a>List类型</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>Redis中的列表在3.2之前的版本是使用ziplist和linkedlist进行实现的。在3.2之后的版本就是引入了quicklist</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>当列表的元素个数小于list-max-ziplist-entries配置（默认512个），同时列表中每个元素的值都小于list-max-ziplist-value配置时（默认64字节），Redis会选用ziplist来作为列表的内部实现来减少内存的使用。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>当<strong>列表类型</strong>的数据再无法满足ziplist的条件时，Redis会使用linkedlist作为列表的内部实现。</font></p>
<h4 id="何为快表quicklist"><a href="#何为快表quicklist" class="headerlink" title="何为快表quicklist"></a>何为快表quicklist</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>相对于linkedlist，没个节点就是一个正常的node，保存一个提交的数据； quicklist，是升级的linkedlist，它的外层仍然是linkedlist，但是没个节点都是一个ziplist。因为ziplist是一块连续的空间，这样就节省了很多指针（next、head指针），只有相邻两个ziplist有指针指向即可。</font><br><img src="/willis-blog/images/2021-10-23/quicklist.svg" alt="&lt;Strong&gt;quicklist&lt;/Strong&gt;"></p>
<h3 id="Set-集合"><a href="#Set-集合" class="headerlink" title="Set 集合"></a>Set 集合</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>Redis中列表和集合都可以用来存储字符串，但是「Set是不可重复的集合，而List列表可以存储相同的字符串」，Set集合是无序的这个和后面讲的ZSet有序集合相对。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>Set底层用两种数据结构存储，一个是hashtable，一个是intset。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>inset为可以理解为数组，使用inset数据结构需要满足下述两个条件：</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>1）元素个数小于配置set-max-inset-entries（默认512）配置的值时</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>2）元素可以转化为整数</font></p>
<figure class="highlight c"><figcaption><span>[intset定义]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">intset</span> &#123;</span></span><br><span class="line"> <span class="comment">//编码类型 </span></span><br><span class="line"> <span class="keyword">uint32_t</span> encoding; </span><br><span class="line"> <span class="comment">// 集合包含的元素数量 </span></span><br><span class="line"> <span class="keyword">uint32_t</span> length; </span><br><span class="line"> <span class="comment">// 保存元素的数组 </span></span><br><span class="line"> <span class="keyword">int8_t</span> contents[];</span><br><span class="line">&#125; intset;</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>无法满足上述条件时，使用hashtable实现</font></p>
<h3 id="Zset集合"><a href="#Zset集合" class="headerlink" title="Zset集合"></a>Zset集合</h3><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>zset为有序（有限score排序，score相同则元素字典序），自动去重的集合数据类型，其底层实现为 字典（dict） + 跳表（skiplist），当数据比较少的时候用ziplist编码结构存储。</font></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>使用ziplist存储zset，需要满足一下条件</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>1）元素数量少于128的时候</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>2）每个元素的长度小于64字节</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>skiplist：不满足上述两个条件就会使用跳表skiplist.跳跃表（skiplist）是一种有序数据结构，它通过在每个节点中维持多个指向其他节点的指针，从而达到快速访问节点的目的</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5>skiplist结构说明</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>header</strong>：指向跳跃表的表头节点。 </font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>tail</strong>：指向跳跃表的表尾节点。 </font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>level</strong>：记录目前跳跃表内，层数最大的那个节点的层数（表头节点的层数不计算在内）。 </font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>length</strong>：记录跳跃表的长度，也即是，跳跃表目前包含节点的数量（表头节点不计算在内）。 </font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>skiplistNode</strong>结构说明</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>层（level）</strong>：节点中用L1、L2、L3等字样标记节点的各个层，L1代表第一层，L2代表第二层，以此类推。每个层都带有两个属性：前进指针和跨度。前进指针用于访问位于表尾方向的其他节点，而跨度则记录了前进指针所指向节点和当前节点的距离。在上面的图片中，连线上带有数字的箭头就代表前进指针，而那个数字就是跨度。当程序从表头向表尾进行遍历时，访问会沿着层的前进指针进行。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>后退（backward）指针</strong>：节点中用BW字样标记节点的后退指针，它指向位于当前节点的前一个节点。后退指针在程序从表尾向表头遍历时使用。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>分值（score）</strong>：各个节点中的1.0、2.0和3.0是节点所保存的分值。在跳跃表中，节点按各自所保存的分值从小到大排列。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=4.5><strong>成员对象（obj）</strong>：各个节点中的o1、o2和o3是节点所保存的成员对象。</font><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font size=3 color=#F98407>表头节点和其他节点的构造是一样的：表头节点也有后退指针、分值和成员对象，不过表头节点的这些属性都不会被用到</font></p>
<figure class="highlight c"><figcaption><span>[跳跃表节点定义]</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> &#123;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 层</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistLevel</span> &#123;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 前进指针</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">forward</span>;</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 跨度</span></span><br><span class="line">        <span class="keyword">unsigned</span> <span class="keyword">int</span> span;</span><br><span class="line"></span><br><span class="line">    &#125; level[];</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 后退指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">zskiplistNode</span> *<span class="title">backward</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 分值</span></span><br><span class="line">    <span class="keyword">double</span> score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 成员对象</span></span><br><span class="line">    robj *obj;</span><br><span class="line"></span><br><span class="line">&#125; zskiplistNode;</span><br></pre></td></tr></table></figure>
<p><img src="/willis-blog/images/2021-10-23/skiplist.svg" alt="&lt;Strong&gt;skiplist&lt;/Strong&gt;"><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;跳跃表节点的level数组可以包含多个元素，每个元素都包含一个指向其他节点的指针，程序可以通过这些层来加快访问其他节点的速度，一般来说，层的数量越多，访问其他节点的速度就越快。<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;每次创建一个新跳跃表节点的时候， 程序都根据幂次定律（power law，越大的数出现的概率越小） 随机生成一个介于 1 和 32 之间的值作为 level 数组的大小， 这个大小就是层的“高度”。 检索都是从高层开始检索， 且每层的前进指针的设定，都应向后找到第一个同一层level。然后再查低层。参考<a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904033589657607#heading-4">https://juejin.cn/post/6844904033589657607#heading-4</a>这篇文章</p>
<hr>
<p>参考文档<br><font color=#406F80 size=3>《Redis设计与实现》</font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://segmentfault.com/a/1190000021486242">https://segmentfault.com/a/1190000021486242</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://www.cnblogs.com/kismetv/p/8654978.html#t32">https://www.cnblogs.com/kismetv/p/8654978.html#t32</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://blog.csdn.net/zhengpeitao/article/details/76573053">https://blog.csdn.net/zhengpeitao/article/details/76573053</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://www.codeleading.com/article/87633231412/">https://www.codeleading.com/article/87633231412/</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="http://redisbook.com/preview/dict/incremental_rehashing.html">http://redisbook.com/preview/dict/incremental_rehashing.html</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://developer.51cto.com/art/202108/676855.htm">https://developer.51cto.com/art/202108/676855.htm</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://juejin.cn/post/6847009772353355783">https://juejin.cn/post/6847009772353355783</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904033589657607">https://juejin.cn/post/6844904033589657607</a></font><br><font color=#406F80 size=3><a target="_blank" rel="noopener" href="https://juejin.cn/post/6844904033589657607#heading-4">https://juejin.cn/post/6844904033589657607#heading-4</a></font></p>
</div><div class="tags"><a href="/willis-blog/tags/Redis/"><i class="fa fa-tag"></i>Redis</a><a href="/willis-blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"><i class="fa fa-tag"></i>数据结构</a><a href="/willis-blog/tags/%E5%8E%8B%E7%BC%A9%E8%A1%A8/"><i class="fa fa-tag"></i>压缩表</a><a href="/willis-blog/tags/%E5%BF%AB%E8%A1%A8/"><i class="fa fa-tag"></i>快表</a><a href="/willis-blog/tags/%E8%B7%B3%E8%A1%A8/"><i class="fa fa-tag"></i>跳表</a></div><div class="post-nav"><a class="next" href="/willis-blog/2021/10/22/JVM%E5%90%8C%E6%AD%A5%E6%94%AF%E6%92%91/">JVM的同步支撑</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://willis-song.gitee.io/willis-blog"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/willis-blog/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/willis-blog/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/willis-blog/tags/elastic/" style="font-size: 15px;">elastic</a> <a href="/willis-blog/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/willis-blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 15px;">微服务</a> <a href="/willis-blog/tags/Swarm/" style="font-size: 15px;">Swarm</a> <a href="/willis-blog/tags/%E6%B8%B8%E7%8E%A9/" style="font-size: 15px;">游玩</a> <a href="/willis-blog/tags/Nginx/" style="font-size: 15px;">Nginx</a> <a href="/willis-blog/tags/%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86/" style="font-size: 15px;">反向代理</a> <a href="/willis-blog/tags/IO/" style="font-size: 15px;">IO</a> <a href="/willis-blog/tags/%E5%90%8C%E6%AD%A5IO/" style="font-size: 15px;">同步IO</a> <a href="/willis-blog/tags/%E5%BC%82%E6%AD%A5IO/" style="font-size: 15px;">异步IO</a> <a href="/willis-blog/tags/%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8/" style="font-size: 15px;">多路复用</a> <a href="/willis-blog/tags/JVM/" style="font-size: 15px;">JVM</a> <a href="/willis-blog/tags/Java/" style="font-size: 15px;">Java</a> <a href="/willis-blog/tags/%E5%90%8C%E6%AD%A5/" style="font-size: 15px;">同步</a> <a href="/willis-blog/tags/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8/" style="font-size: 15px;">线程安全</a> <a href="/willis-blog/tags/%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9/" style="font-size: 15px;">指针压缩</a> <a href="/willis-blog/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/willis-blog/tags/java/" style="font-size: 15px;">java</a> <a href="/willis-blog/tags/InnoDb/" style="font-size: 15px;">InnoDb</a> <a href="/willis-blog/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 15px;">操作系统</a> <a href="/willis-blog/tags/%E7%94%A8%E6%88%B7%E6%80%81/" style="font-size: 15px;">用户态</a> <a href="/willis-blog/tags/%E6%A0%B8%E6%80%81/" style="font-size: 15px;">核态</a> <a href="/willis-blog/tags/%E7%AE%A1%E6%80%81/" style="font-size: 15px;">管态</a> <a href="/willis-blog/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/" style="font-size: 15px;">消息队列</a> <a href="/willis-blog/tags/kafka/" style="font-size: 15px;">kafka</a> <a href="/willis-blog/tags/%E8%BF%9B%E7%A8%8B/" style="font-size: 15px;">进程</a> <a href="/willis-blog/tags/%E7%BA%BF%E7%A8%8B/" style="font-size: 15px;">线程</a> <a href="/willis-blog/tags/%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98/" style="font-size: 15px;">共享内存</a> <a href="/willis-blog/tags/%E5%86%85%E5%AD%98/" style="font-size: 15px;">内存</a> <a href="/willis-blog/tags/netty/" style="font-size: 15px;">netty</a> <a href="/willis-blog/tags/Redis/" style="font-size: 15px;">Redis</a> <a href="/willis-blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 15px;">数据结构</a> <a href="/willis-blog/tags/%E5%8E%8B%E7%BC%A9%E8%A1%A8/" style="font-size: 15px;">压缩表</a> <a href="/willis-blog/tags/%E5%BF%AB%E8%A1%A8/" style="font-size: 15px;">快表</a> <a href="/willis-blog/tags/%E8%B7%B3%E8%A1%A8/" style="font-size: 15px;">跳表</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/10/23/Redis%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AF%A6%E8%A7%A3/">Redis数据结构</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/10/22/JVM%E5%90%8C%E6%AD%A5%E6%94%AF%E6%92%91/">JVM的同步支撑</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/10/22/%E5%85%B3%E4%BA%8EJVM%E6%8C%87%E9%92%88%E5%8E%8B%E7%BC%A9/">关于JVM指针压缩</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/10/14/Netty%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/">Netty实现原理与源码分析</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/10/10/IO%E7%9A%84%E8%BF%9B%E5%8C%96/">IO的进化过程</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/09/25/Nginx-%E9%85%8D%E7%BD%AE/">Nginx-配置</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/08/04/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97-kafka-1/">消息队列-kafka-1</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/06/19/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/">操作系统-内存管理</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/06/03/Maven%E7%9A%84docker%E6%8F%92%E4%BB%B6/">Maven的Docker插件</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B&%E7%BA%BF%E7%A8%8B/">操作系统-进程/线程</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/willis-blog/." rel="nofollow">Willis's Note.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/willis-blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/willis-blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/willis-blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/willis-blog/js/smartresize.js?v=1.0.0"></script></div></body></html>