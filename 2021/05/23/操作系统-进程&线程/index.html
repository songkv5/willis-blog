<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content=""><title>操作系统-进程/线程 | Willis's Note</title><link rel="stylesheet" type="text/css" href="/willis-blog/css/style.css?v=1.0.0"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/normalize.css/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/pure-min.min.css"><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/npm/purecss/build/grids-responsive-min.css"><link rel="stylesheet" href="//cdn.jsdelivr.net/npm/font-awesome@4.7.0/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/jquery/dist/jquery.min.js"></script><link rel="icon" mask="" sizes="any" href="/willis-blog/favicon.ico"><link rel="Shortcut Icon" type="image/x-icon" href="/willis-blog/favicon.ico"><link rel="apple-touch-icon" href="/willis-blog/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/willis-blog/apple-touch-icon.png"><script type="text/javascript" src="//cdn.jsdelivr.net/npm/clipboard/dist/clipboard.min.js"></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.js"></script><link rel="stylesheet" href="//cdn.jsdelivr.net/gh/codeseven/toastr/build/toastr.min.css"><meta name="generator" content="Hexo 5.4.0"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">操作系统-进程/线程</h1><a id="logo" href="/willis-blog/.">Willis's Note</a><p class="description"></p></div><div id="nav-menu"><a class="current" href="/willis-blog/."><i class="fa fa-home"> 首页</i></a><a href="/willis-blog/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/willis-blog/about/"><i class="fa fa-user"> 关于</i></a><a href="/willis-blog/atom.xml"><i class="fa fa-rss"> 订阅</i></a></div></div><div class="pure-g" id="layout"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">操作系统-进程/线程</h1><div class="post-meta">2021-05-23<script src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> 阅读</span></span></div><div class="post-content"><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><strong>并发</strong>: 现代操作系统采用并行处理技术,在「单处理机」计算机系统中,多个任务的同时执行称为「并发」.程序的并发执行,指的是多个程序都处于已经开始,但是未执行完毕的状态中.<br><strong>进程</strong>: 指一个具有一定独立功能的程序关于某个数据集合的一次运行活动.</p>
<h2 id="进程"><a href="#进程" class="headerlink" title="进程"></a>进程</h2><h3 id="1-进程状态"><a href="#1-进程状态" class="headerlink" title="1. 进程状态"></a>1. 进程状态</h3><p>(1)就绪状态<br>当进程获得了除CPu之外的所有资源,他已经准备就绪.一旦得到CPU控制权,就可以立即运行.该进程所处的状态就是就绪状态<br>(2)运行状态<br>进程通过「进程调度」和「处理机分派」后,得到CPU的控制权,该进程对应的程序正在处理机上运行,他所处的状态为运行状态.<br>(3)等待状态<br>若以进程正在等待某一事件发生(如等待输入/输出操作的完成)而暂时停止执行,这时,即使给他cpu控制权,他也无法执行,则称该进程处于等待状态,又可称为阻塞状态.<br><img src="/willis-blog/images/2021-05-23/process-1.svg" alt="进程状态变迁图"></p>
<h3 id="2-进程控制块-PCB"><a href="#2-进程控制块-PCB" class="headerlink" title="2.进程控制块(PCB)"></a>2.进程控制块(PCB)</h3><p>为了描述进程,将状态信息和与进程有关的信息组织成一个数据结构,这个数据结构就是进程控制块(Process Control Block).<br><font color=#BD1232 size=4>当系统创建一个进程时,必须为它设置一个PCB,然后根据PCB的信息对进程实施控制和管理.进程任务完成时,系统撤销它的PCB,进程也随之消亡</font></p>
<h4 id="进程控制块的结构"><a href="#进程控制块的结构" class="headerlink" title="进程控制块的结构"></a>进程控制块的结构</h4><table>
<thead>
<tr>
<th align="left">PCB结构</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><image width=300/>进程标识符</td>
<td align="left"><font size=3>每个进程有的一个唯一标识符,用字符或编号表示. 在创建一个进程时,由进程创建者给出进程的标识符</font></td>
</tr>
<tr>
<td align="left">进程状态</td>
<td align="left"><font size=3>该项说明了当前进程所处的状态(运行、等待、就绪),可以用数字(0,1,2)或字符(run、wait、ready)来表示. 只有进程处于就绪状态时才能获得处理机.当进程处于阻塞状态时,要在PCB中说明阻塞的原因.</font></td>
</tr>
<tr>
<td align="left">当前队列指针</td>
<td align="left"><font size=3>该项登记了处于「同一状态的」下一个PCB的地址,以此将处于同一状态的所有进程勾连起来.每个队列有一个队列头,其内容为队列第一个元素的地址.例如: 将所有处于就绪状态的进程连在一起,成为就绪队列; 把所有因「等待某个事件」而处于等待状态的进程连在一起就组成「各种」等待队列.</font></td>
</tr>
<tr>
<td align="left">进程优先级</td>
<td align="left"><font size="3">进程的优先级反映了进程要求CPU的紧迫程度.通常由用户预先提出或者由操作系统指定.</font></td>
</tr>
<tr>
<td align="left">CPU现场保护区</td>
<td align="left"><font size="3">当进程由于某种原因释放处理机时,CPU现场信息被保存在PCB的该区域,以便该进程重新获得处理机后能继续执行. 通常被保护的信息由工作寄存器、指令计数器以及程序状态字等.</font></td>
</tr>
<tr>
<td align="left">通信信息</td>
<td align="left"><font size="3">每个进程在运行过程中与其他进程进行通信时所记录的有关信息.如,可以包含正等待着本进程接收的消息个数,第一个消息的开始地址</font></td>
</tr>
<tr>
<td align="left">家族联系</td>
<td align="left"><font size="3">在PCB中必须之名本进程与家族的关系,如他的子进程和父进程的标识符</font></td>
</tr>
<tr>
<td align="left">占有资源清单</td>
<td align="left"><font size="3">–</font></td>
</tr>
</tbody></table>
<p><font color=#BD1232 size=4>从结构上讲,每个进程都由一个程序段(包括数据)和一个进程控制块组成</font></p>
<h3 id="3-进程控制"><a href="#3-进程控制" class="headerlink" title="3.进程控制"></a>3.进程控制</h3><p>进程控制负责控制进程状态的变化. 操作系统核心具有「创建进程」、「撤销进程」、「使进程等待」、「唤醒进程」等功能.这些功能由特定功能的程序组成,而且通过「<font color="#BD1232">原语</font>」操作来实现控制和管理.<br><em>原语</em>: <font color=#406F80 size=4>原语是一种特殊的「系统调用」,它可以完成一个特定的功能,一般为外层软件所调用,其特点是原语执行不可中断,即原语是原子性的,不可再分的.在操作系统中,原语作为一个基本单位出现.</font></p>
<h4 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="(1)进程创建"></a>(1)进程创建</h4><p>无论是系统还是用户创建进程都必须调用创建原语来实现. <font color="#BD1232">创建原语的主要功能是创建一个置顶标识符的进程. 主要任务是形成进程控制块PCB,所以, 调用者必须提供形成PCB的有关参数以便在创建时填入.</font><br><font size=4 color="#406F80">在unix或linux系统中,父进程创建一个子进程是,该子进程继承父进程占用的系统资源,以及除了进程内部标识符以外的其他特性,所以unix或linux系统的进程创建原语fork不带参数</font><br><em>创建原语的算法描述如下:</em>    </p>
<figure class="highlight text"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">从PCB资源池申请一个空闲的PCB结构;</span><br><span class="line">if (无空PCB结构)</span><br><span class="line">	return 错误码;</span><br><span class="line">用入口参数设置PCB内容;</span><br><span class="line">置进程为“就绪(ready)”状态;</span><br><span class="line">将新进程的PCB插入到就绪队列;</span><br><span class="line">return 新进程的pid;</span><br></pre></td></tr></table></figure>
<p><font color=#406F80 size=4>「PCB资源池」是PCB集合.他是系统内核区中的一个结构数组,用来存放进程控制块. 该集合大小为n * pcb_size. 其中, pcb_size为pcb结构的大小,n为系统具有的pcb个数. pcb_size和n值在系统生成时确定. 系统初始化时,每个PCB结构中进程标识符单元内都存放“-1”,标识该PCB结构为空. 当创建原语执行成功欧,该项内容为新创建进程的标识符.</font></p>
<h4 id="2-进程撤销"><a href="#2-进程撤销" class="headerlink" title="(2)进程撤销"></a>(2)进程撤销</h4><p>进程撤销的功能包括: 撤销本进程、撤销一个指定标识符的进程或撤销一组子进程,后面两个撤销明林职能用于父进程撤销子进程.<br>当一个进程执行完成之后,就会终止自己, 这时应该撤销进程. 他的功能是将当前运行进程(这里指的是自我撤销)的PCB结构归还到PCB资源池,所占用的资源归还给父进程,然后转进进程调度程序. 进程撤销由撤销原语实现,其命令形式为kill或exit.该命令没有参数,执行结果也无返回</p>
<h4 id="3-进程阻塞"><a href="#3-进程阻塞" class="headerlink" title="(3)进程阻塞"></a>(3)进程阻塞</h4><p>进程阻塞通过阻塞原语(或称挂起命令)实现.阻塞原语的形式为<br>susp(chan);<br>入口参数chan: 进程等待的原因.<br>阻塞命令的功能: 停止调用进程的执行, 将CPU线程保存到该进程的PCB保护区;然后,改变其状态为“等待”,并插入到等待chan的等待队列; 最后是控制转向调度程序</p>
<h4 id="4-进程唤醒"><a href="#4-进程唤醒" class="headerlink" title="(4)进程唤醒"></a>(4)进程唤醒</h4><p>唤醒原语的形式: wakeup(chan);<br>唤醒原语的功能: 当进程等待的事件发生时,唤醒等待该事件的进程.</p>
<h3 id="4-进程同步"><a href="#4-进程同步" class="headerlink" title="4. 进程同步"></a>4. 进程同步</h3><h4 id="上锁与开锁"><a href="#上锁与开锁" class="headerlink" title="上锁与开锁"></a>上锁与开锁</h4><h4 id="信号灯PV操作"><a href="#信号灯PV操作" class="headerlink" title="信号灯PV操作"></a>信号灯PV操作</h4><h3 id="5-线程"><a href="#5-线程" class="headerlink" title="5. 线程"></a>5. 线程</h3><p>传统的多处理机由若干台处理机组成,每台处理机每次运行单个现场,也就是说,没太处理机有一个有限硬件资源的单一控制线索(单线程的进程).这样的多处理机在进行远程访问期间会出现等待现象,处理机在这段时间间隔内处于空闲.为了提高处理机的并行操作能力,提出了多线程的概念.在每台处理机上建立多个运行现场,这样每台处理机有多个控制线程.<br><font color=#406F80 size=4>在传统的操作系统中,每个进程只存在一条控制线索和一个程序计数器.但在现代操作系统中,有些提供了对单个进程中多条控制线索的支持.这些控制线索成为线程,也称为轻量级进程</font><br><strong>描述一个线程</strong><br>(1)线程是进程中的一条执行路径<br>(2)他有自己私有的堆栈和处理机执行环境(尤其是处理器寄存器)<br>(3)它共享父进程的主存<br>(4)它是单个进程所创建的许多个同事存在的线程中的一个.<br>基于进程与线程的联系,将「进程的组成」概括如下<br>(1)一个可执行程序,他定义了初始代码和数据<br>(2)一个私用地址空间(address space),它是进程可以使用的一组虚拟主存地址<br>(3)进程执行时所需的系统资源(文件、信号灯、通信端口等)是由操作系统分配给进程的;<br>(4)若系统支持线程运行,那么,每个进程只少有一个执行线程.<br><font size=4 color="#BD1232">进程是任务调度的单位,也是系统资源分配的单位;线程是进程中的一条执行路径,单系统支持多线程处理时,线程是任务调度的单位,但不是系统资源分配的单位. 线程完全继承父进程占有的资源,当他活动时,具有自己的运行现场</font></p>
<h4 id="线程的特点"><a href="#线程的特点" class="headerlink" title="线程的特点"></a>线程的特点</h4><p>相对于进程而言,线程的创建与管理开销要小得多. 因为线程可以共享父进程的所有程序和全局数据,这意味着创建一个新线程只涉及最小量的主存分配(线程表),也意味着一个进程创建的多个线程可以共享地址区域和数据.<br>在进程内创建多线程,可以提高系统的并行处理能力.</p>
<h4 id="线程的状态"><a href="#线程的状态" class="headerlink" title="线程的状态"></a>线程的状态</h4><p>如果一个系统支持线程的创建与线程的活动,那么,处理机调度的最小单位是线程而不是进程.一个进程可以创建一个线程,那么它具有单一的控制路径,一个进程可以创建多个线程,那么它就具有多个控制路径.这是,线程是争夺CPU的单位.</p>
<p><strong>线程的状态与变迁</strong></p>
<table>
<thead>
<tr>
<th align="left">状态</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">创建<image width=100/></td>
<td align="left"><font size=4>建立一个新的线程,新生的线程将处于新建状态.此时他已经又了相应的主存空间和其它资源,并已被初始化</font></td>
</tr>
<tr>
<td align="left">就绪</td>
<td align="left"><font size=4>线程处于线程就绪队列中,等待被调度.此时它已经具备了运行的条件,一旦分到CPU时间,就可以立即去运行</font></td>
</tr>
<tr>
<td align="left">运行</td>
<td align="left"><font size=4>一个线程正在占用CPU,运行他的程序</font></td>
</tr>
<tr>
<td align="left">等待</td>
<td align="left"><font size=4>一个正在执行的线程如果发生某些事件,如被挂起或需要执行费时输入/输出操作是,将让出CPU,暂时终止自己的执行,进入等待状态,等待另一个线程唤醒它</font></td>
</tr>
<tr>
<td align="left">终止</td>
<td align="left"><font size=4>一个线程已经推出,但该信息还没有被其他线程所收集(在nunix中,父线程还没有做wait)</font></td>
</tr>
</tbody></table>
<h3 id="6-实例"><a href="#6-实例" class="headerlink" title="6. 实例"></a>6. 实例</h3><h4 id="6-1-进程创建与应用实例"><a href="#6-1-进程创建与应用实例" class="headerlink" title="6.1 进程创建与应用实例"></a>6.1 进程创建与应用实例</h4><p>在Unix/Linux系统中,用户创建一个新进程的唯一方法就是调用系统调用fork. 调用fork的进程称为父进程,而新创建的进程叫做子进程.语法格式如:pid = fork();<br><em>fork的执行过程如下</em><br>(1)为新进程分配一个新的PCB结构;<br>(2)为子进程赋一个唯一的进程标识符(PID)<br>(3)做一个父进程上下文的逻辑副本.<font size="4" color="#406F80">进程的正文区(代码段)可被几个进程所共享,所以核心只要增加某个正文区的引用数即可,而不是真的将该区拷贝到一个新的内存物理区.这就意味着父子进程将执行相同的代码.</font><font size=4 color="#BD1232">但是数据段和堆栈段属于进程的私有数据,需要拷贝到新的内存区中</font><br>(4)增加与该进程相关联的文件表和索引节点表的引用书.这就意味着父进程代开的文件子进程可以继续使用.<br>(5)父进程返回子进程的进程号,对子进程返回0</p>
<p><em>执行新程序</em><br>在Unix/Linux系统中, 若想让进程执行一个新的程序,需要使用exec()类函数.在linux中,这类函数包括:execl()、execlp()、execle()、execv()、execvp()、execve(). exec()函数族的作用是根据参数指定的文件名找到可执行文件,并用它来取代调用进程的内容,换句话说,就是在调用进程内部执行一个可执行文件. 一个进程点调用了exec()类函数,系统将该进程的代码段替换成新的程序的代码,废弃原有的数据段和堆栈段,并根据新程序分配新的数据段与堆栈段,唯一留下来的就是进程的PCB和进程号.最后,对系统而言,还是同一个进程,不过已经是一个新的程序了.</p>
<h4 id="6-2-等待进程、线程终止"><a href="#6-2-等待进程、线程终止" class="headerlink" title="6.2 等待进程、线程终止"></a>6.2 等待进程、线程终止</h4><p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在Unix/linux系统中,一个进程可以通过系统调用wait使它的执行与子进程的终止同步.格式为:pid = wait(stat_addre);<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;wait()函数是父进程暂停执行,直到他的一个子进程结束为止. 该函数的返回值是终止运行的子进程的PID. 参数status所指向的变量存放子进程的退出码,即子进程的main函数返回的值或子进程中exit()函数的参数.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在linux中,waitpid(pid_t pid, int * status, int options)也用来等待子进程的结束,但它用于等待某个特定进程的结束. 参数pid指明要等待的子进程的pid,参数status的含义与wait函数中的status相同.</p>
<h3 id="7-共享内存"><a href="#7-共享内存" class="headerlink" title="7. 共享内存"></a>7. 共享内存</h3><p>共享内存是进程间通信最简单的方式之一.因为所有进程共享同一块内存,共享内存是各种进程间通信方式中具有最高的效率的一种通信方式.<br><font size=4 color="#406F80">因为系统内核没有对访问共享内存进行同步,程序编制者必须提供自己的同步措施.如,在数据被写入之前不允许进程从共享内存中读取信息、不允许两个进程同时向同一个共享内训地址写入数据等</font><br>在linux系统中,每个进程都会维护一个从内存地址到虚拟内存页面之间的映射关系.尽管每个进程都有自己的内存地址,不同的进程可以同时将一个内存页面映射到自己的地址空间中,从而达到共享内存的目的.</p>
<h4 id="虚拟内存的使用过程"><a href="#虚拟内存的使用过程" class="headerlink" title="虚拟内存的使用过程"></a>虚拟内存的使用过程</h4><p>使用虚拟内存,进程必须先分配它.随后需要访问这个共享内存块的每一个进程都必须将这个共享内存绑定到自己的地址空间中.当完成通信之后,所有进程都将脱离共享内存,并且有一个进程释放共享内存.</p>
<ol>
<li><p>共享内存分配<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#406F80">分配一个新的共享内存会创建新的内存页面</font>.因为所有进程都希望共享对同一块内存的访问,只应由一个进程创建一块新的共享内存. 在此分配一块已经存在的内存块不会创建新的页面,而只是会返回一个标识该内存块的标识符.一个进程如需使用这个共享内存块,则首先需要将它绑定到自己的地址空间中.这样会创建一个从进程本身「虚拟地址」到「共享内存页面」的映射关系.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程通过调用shmget(shared memory get,获取共享内存)来分配一个共享内存块.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#406F80">该函数第一个参数是一个标识共享内存的键值</font>,<font color="#BD1232"> 彼此无关进程可以通过指定同一个键值获取对同一个共享内存块的访问</font>. 为变其他程序也可能使用同一键值分配共享内存,可以使用特殊常量IPC_PRIVATE作为键值,以确保每次建立一个全新的共享内存块.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第二个参数指定所申请的共享内存的大小<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;第三个参数是一组标志,通过特定常量的按位或操作来shmget.如下<br>int segment_id = shmget(shm_key, getpagesize(), IPV_CREATE_S_IRUSR|S_IWUSR), 调用成功后,shmget将返回一个共享内存标识符.</p>
</li>
<li><p>共享内存的绑定<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程通过shmat(shared memory attach,绑定到共享内存)将共享内存也绑定到进程自己地址空间的虚拟地址.该函数第一个参数是shmget的返回值;第二个参数只一个指针,,如果传NULL,linux会自动选择一个合适的地址用于映射;第三个参数是一个标志位,有以下两种可能:(1)SHM_RND,表示第二个桉树指定的地址应该被向下靠拢到内存页面大小的整数倍(2)SHM_RDONLY表示这个内存块仅允许读取操作禁止写入操作. 如果调用成功,会返回绑定的共享内存块对应的地址<br>shmdt(shared memory detach,脱离共享内存).将shmat返回值传给这个函数,即可脱离共享内存.该方法不会删除共享内存块</p>
</li>
<li><p>共享内存释放<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;shmctl(shared memory control,控制共享内存)函数会返回一个共享内存的相关信息,同时,shmctl允许程序修改这些信息. 第一个参数是一个共享内存标识符.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<font color="#BD1232">结束使用共享内存块的时候应该使用shmctl()进行释放(第二个参数是IPC_RMID,第三个参数传NULL),以防止超过系统所允许的共享内存块的总数限制.调用exit和exec会使进程脱离共享内存块,但不会删除这个内存块.</font></p>
</li>
</ol>
<h3 id="8-调度"><a href="#8-调度" class="headerlink" title="8. 调度"></a>8. 调度</h3><p>进程调度分为「调度」和「分派」两部分.分别由调度程序和分派程序执行.<font color="#406F80">调度程序负责将一个进程插入到就绪队列并按照一定原则保持队列结构;分派程序是将进程从就绪队列中移出并建立该进程执行的机器状态</font></p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程调度的功能: 进程调度是指按照一定的调度策略,动态地把处理机分配给就绪队列中的某一进程,使之执行. 具体分为三步:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) <strong>记录进程有关情况</strong>.进程在活动期间其状态是可以改变的,如由运行转换到阻塞、由就绪转到运行.相应的,该进程的PCB就在运行指针、各种等待队列和就绪队列之间转换.进程进入就绪队列的排序规则体现了调度思想.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) <strong>决定分配策略</strong>. 在处理机空闲时,根据一定的原则选择一个进程去运行,同时确定获得处理机的时间片的长短.进程调度策略实际上是由就绪队列的排序原则体现的.若按优先调度原则,进程就绪队列按优先级高低排序;若按先来先服务原则,则按进程来到的先后顺序排序.由「入链子程序」实施这一功能.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) <strong>实施处理机的分配和回收</strong>.当调度时机来到时,根据调度原则选择一个进程去运行,将选中进程从就绪队列中移出,改状态为“运行”,并将该进程的处理机线程信息送到相应的寄存器中,将处理机控制权真正交给被选中的进程.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程切换: 保留原来运行进程的状态信息,并用保留在选中进程PCB中的状态信息设置CPU现场. 进程切换所需的时间是额外开销,因为切换时系统并不能做其他工作.进程切换所需的时间与硬件息息相关,如主存速度、要复制的寄存器数量、是否有特殊指令等.<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;进程调度时机:<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1)进程完成其任务时;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2)在一次系统调用之后(中断),该调用使用当前进程暂时不能继续运行时;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3)在一次出错陷入之后,该陷入使现行进程在出错处理时「被挂起时」;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4)在分时操作系统中,当进程用完规定的时间片,时钟中断时该进程让出处理时机;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5)在采用可剥夺调度方式的系统,当具有更高优先级的进程要求处理机时.</p>
<h4 id="线程调度"><a href="#线程调度" class="headerlink" title="线程调度"></a>线程调度</h4><p>线程调度采用优先调度算法.对于任务较紧急,重要的线程,赋予较高的优先级.线程就绪队列按照优先级的高低排序,对于优先级相同的进程,遵循“先进先出”的原则.<br><strong>举例:</strong><br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;在windows系统中,有两个调度程序,一个是初始调度程序,一个是时间片调度程序. 初始调度程序负责计算线程优先级;时间片调度程序负责确定时间,并分配给线程.具体过程如下<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(1) 初始调度程序考察系统的每个进程,计算进程读经线程的执行优先级,去0 ~ 31之间的整数;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(2) 初始调度程序确定当前具有最高优先级的线程,低于此值的正在运行的线程将被挂起,一旦某个线程被挂起,初始调度程序在这个时间片期间不会再注意盖线程,除非再进行优先级的计算;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(3) 时间片调度程序根据优先级值和VM的当前状态计算并分配给每个线程时间片的分数;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(4) 线程运行;<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(5) 初始调度程序每隔20ms再次计算线程的优先级并作出评级</p>
<hr>
<p>参考文献<br><font size=3 color=#7CB5B5>《计算机操作系统》</font></p>
</div><div class="tags"></div><div class="post-nav"><a class="pre" href="/willis-blog/2021/06/03/Maven%E7%9A%84docker%E6%8F%92%E4%BB%B6/">Maven的Docker插件</a><a class="next" href="/willis-blog/2021/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E6%9C%BA%E7%89%B9%E6%9D%83%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">操作系统-处理机特权级相关知识</a></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form class="search-form" action="//www.baidu.com/baidu" method="get" accept-charset="utf-8" target="_blank"><input type="search" name="word" maxlength="20" placeholder="Search"/><input type="hidden" name="si" value="https://willis-song.gitee.io/willis-blog"/><input name="tn" type="hidden" value="bds"/><input name="cl" type="hidden" value="3"/><input name="ct" type="hidden" value="2097152"/><input name="s" type="hidden" value="on"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/willis-blog/tags/Mysql/" style="font-size: 15px;">Mysql</a> <a href="/willis-blog/tags/InnoDb/" style="font-size: 15px;">InnoDb</a> <a href="/willis-blog/tags/Docker/" style="font-size: 15px;">Docker</a> <a href="/willis-blog/tags/elastic/" style="font-size: 15px;">elastic</a> <a href="/willis-blog/tags/Dubbo/" style="font-size: 15px;">Dubbo</a> <a href="/willis-blog/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/" style="font-size: 15px;">微服务</a> <a href="/willis-blog/tags/Swarm/" style="font-size: 15px;">Swarm</a> <a href="/willis-blog/tags/%E6%B8%B8%E7%8E%A9/" style="font-size: 15px;">游玩</a> <a href="/willis-blog/tags/jvm/" style="font-size: 15px;">jvm</a> <a href="/willis-blog/tags/java/" style="font-size: 15px;">java</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最近文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/06/03/Maven%E7%9A%84docker%E6%8F%92%E4%BB%B6/">Maven的Docker插件</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/23/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B&%E7%BA%BF%E7%A8%8B/">操作系统-进程/线程</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/22/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%A4%84%E7%90%86%E6%9C%BA%E7%89%B9%E6%9D%83%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/">操作系统-处理机特权级相关知识</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/18/Docker%E5%B7%A5%E5%85%B7-Docker%20Machine/">Docker Machine</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/05/13/docker%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B/">docker网络模型</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/03/25/Docker-Registry/">Docker-registry</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/03/25/%E6%B8%B8%E7%8E%A9%E6%94%BB%E7%95%A5/">游玩攻略</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/03/07/Docker-Swarm%E5%85%A5%E9%97%A8/">Docker swarm-入门</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/02/24/dubbo%E7%BA%BF%E7%A8%8B%E6%A8%A1%E5%9E%8B/">dubbo线程模型</a></li><li class="post-list-item"><a class="post-list-link" href="/willis-blog/2021/02/24/Dubbo-Service%20Consumer/">2021-02-24-Dubbo-Service Consumer</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://www.baidu.com/" title="百度" target="_blank">百度</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">Copyright © 2021 <a href="/willis-blog/." rel="nofollow">Willis's Note.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a class="show" id="rocket" href="#top"></a><script type="text/javascript" src="/willis-blog/js/totop.js?v=1.0.0" async></script><script type="text/javascript" src="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.js" async></script><script type="text/javascript" src="/willis-blog/js/fancybox.js?v=1.0.0" async></script><link rel="stylesheet" type="text/css" href="//cdn.jsdelivr.net/gh/fancyapps/fancybox/dist/jquery.fancybox.min.css"><script type="text/javascript" src="/js/copycode.js" successtext="复制成功!"></script><link rel="stylesheet" type="text/css" href="/css/copycode.css"><script type="text/javascript" src="/willis-blog/js/codeblock-resizer.js?v=1.0.0"></script><script type="text/javascript" src="/willis-blog/js/smartresize.js?v=1.0.0"></script></div></body></html>